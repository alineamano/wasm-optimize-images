#define STB_IMAGE_IMPLEMENTATION
#define STB_IMAGE_WRITE_IMPLEMENTATION

#include "stb_image.h"
#include "stb_image_write.h"

#include <cstdlib>
#include <cstring>
#include <vector>
#include <iostream>

#include <emscripten/emscripten.h>

extern "C" {

  /**
  * @brief Callback function used by stb_image_write to store JPEG data in memory.
  * 
  * This function accumulates JPEG bytes into a buffer.
  * 
  * @param context Pointer to the output buffer (std::vector<unsigned char>) to accumulate data.
  * @param data Pointer to the bytes generated in this JPEG chunk.
  * @param size Number of bytes in 'data' to copy to the buffer.
  */
  void writeToBuffer(void* context, void* data, int size) {
    std::vector<unsigned char>* buffer = static_cast<std::vector<unsigned char>*>(context);
    unsigned char* bytes = static_cast<unsigned char*>(data);
    // buffer->insert(): appends 'size' bytes from 'bytes' into the vector
    buffer->insert(buffer->end(), bytes, bytes + size);
  }

  /**
  * @brief Compress an RGB(A) image to JPEG in memory using stb_image_write.
  * 
  * @param rawImageData Pointer to the raw image bytes (RGBA or RGB).
  * @param width Image width.
  * @param height Image height.
  * @param channels Number of channels (usually 3 or 4).
  * @param desiredQuality JPEG quality (1 to 100).
  * @param outputSize Pointer to an int where the size of the generated JPG will be stored.
  * 
  * @return Pointer to the generated JPG data (allocated with malloc).
  *         Must be freed using `freeCompressedImage()` in JS after use.
  *         Returns nullptr on failure.
  */
  EMSCRIPTEN_KEEPALIVE
  unsigned char* compressImageToJpg(
    unsigned char* rawImageData, 
    int width, 
    int height, 
    int channels, 
    int desiredQuality, 
    int* outputSize
  ) {
    if (!rawImageData || width <= 0 || height <= 0 || channels < 3 || !outputSize) {
      return nullptr;
    }

    std::vector<unsigned char> jpegBuffer;
    std::vector<unsigned char> rgbImageData;

    const int desiredChannels = 3;

    unsigned char* pixelData = rawImageData;

    // Convert RGBA to RGB if needed (JPEG does not support alpha channel)
    if (channels == 4) {
      rgbImageData.resize(width * height * desiredChannels);

      for (int srcIndex = 0, destIndex = 0; srcIndex < width * height * 4; srcIndex += 4, destIndex+=3) {
        rgbImageData[destIndex + 0] = rawImageData[srcIndex + 0]; // R
        rgbImageData[destIndex + 1] = rawImageData[srcIndex + 1]; // G
        rgbImageData[destIndex + 2] = rawImageData[srcIndex + 2]; // B
      }
      // .data() returns a pointer to the underlying buffer (unsigned char*)
      pixelData = rgbImageData.data();
    }

    // Write JPEG data to memory using the custom callback
    bool success = stbi_write_jpg_to_func(
      writeToBuffer,      // Callback function for writing JPEG chunks
      &jpegBuffer,        // Context passed to the callback (output buffer)
      width,
      height,
      desiredChannels,    // JPEG requires 3 channels (RGB)
      pixelData,          // Pointer to source image data
      desiredQuality      // Compression quality
    );

    if (!success) {
      printf("Failed to compress image.\n");
      *outputSize = 0;    // Indicates compression failure (no data written)
      return nullptr;
    }

    // Allocate memory for the compressed output
    unsigned char* compressedData = (unsigned char*) malloc(jpegBuffer.size());

    if (!compressedData) {
      std::cerr << "Failed to allocate memory for compressed image.\n";
      *outputSize = 0;    // Allocation failure â€” return size 0
      return nullptr;
    }

    // Copy data from std::vector to raw buffer
    memcpy(compressedData, jpegBuffer.data(), jpegBuffer.size());
    
    // Store the output size in the provided pointer
    *outputSize = static_cast<int>(jpegBuffer.size());

    return compressedData;
  }

  /**
 * @brief Frees memory allocated for a compressed JPEG image (generated by `compressImageToJpg`).
 * 
 * @param data Pointer to the JPEG data previously allocated with malloc.
 * 
 * This function must be used because the malloc is done on the C++ side,
 * and JavaScript cannot free this memory directly.
 */
  EMSCRIPTEN_KEEPALIVE
  void freeCompressedImage(unsigned char* data) {
    free(data);
  }
}
